generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String              @id @default(uuid())
  walletAddress      String              @unique
  createdAt          DateTime            @default(now())
  bannerImage        String?
  bio                String?
  creatorAppliedAt   DateTime?
  creatorApprovedAt  DateTime?
  isCreator          Boolean             @default(false)
  profileCompleted   Boolean             @default(false)
  profilePicture     String?
  updatedAt          DateTime            @updatedAt
  username           String?             @unique
  creatorApplication CreatorApplication?
  projects           Project[]
  following          UserFollow[]        @relation("UserFollowing")
  followers          UserFollow[]        @relation("UserFollows")
  preferences        UserPreference[]
  socials            UserSocial[]        @relation("UserSocials")
  suggestions        UserSuggestion[]
  lists              UserList[]
  // P2P Trading relations
  initiatedTrades    Trade[]             @relation("TradeInitiator")
  receivedTrades     Trade[]             @relation("TradeCounterparty")
  tradeMessages      TradeMessage[]
  tradeHistory       TradeHistory[]
}

model CreatorApplication {
  id                     String    @id @default(uuid())
  userId                 String    @unique
  creatorType            String
  displayName            String
  tagline                String?
  avatar                 String?
  banner                 String?
  bio                    String
  skills                 String[]
  portfolio              String?
  achievements           String?
  socialLinks            Json?
  contentTypes           String[]
  uploadFrequency        String
  targetAudience         String
  uniqueValue            String?
  acceptTerms            Boolean   @default(false)
  acceptCreatorAgreement Boolean   @default(false)
  understandFees         Boolean   @default(false)
  status                 String    @default("pending")
  submittedAt            DateTime  @default(now())
  reviewedAt             DateTime?
  reviewNotes            String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Project {
  id          String       @id @default(uuid())
  name        String
  description String
  banner      String?
  genre       String?
  concept     String?
  status      String       @default("draft")
  creatorId   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  collections Collection[]
  creator     User         @relation(fields: [creatorId], references: [id], onDelete: Cascade)
}

model Collection {
  id                String            @id @default(uuid())
  address           String            @unique
  name              String
  symbol            String
  description       String?
  image             String?
  bannerImage       String?
  profileImage      String?
  creatorAddress    String
  royaltyPercentage Float             @default(0)
  chainId           Int               @default(11155111)
  claimPhases       String?
  projectId         String?
  about             Json?
  story             String?
  utility           String?
  roadmap           Json?
  socialLinks       Json?
  teamMembers       Json?
  tags              String[]
  category          String?
  isDeployed        Boolean           @default(false)
  deployedAt        DateTime?
  transactionHash   String?
  totalSupply       Int               @default(0)
  maxSupply         Int?
  mintedSupply      Int               @default(0)
  isVerified        Boolean           @default(false)
  isFeatured        Boolean           @default(false)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  contractType      String            @default("DropERC721")
  sharedMetadata    Json?
  sharedMetadataSetAt DateTime?
  project           Project?          @relation(fields: [projectId], references: [id])
  collectionTraits  CollectionTrait[]
  nfts              Nft[]
}

model Nft {
  id           String     @id @default(uuid())
  tokenId      String
  collectionId String
  name         String
  description  String?
  image        String
  attributes   Json?
  metadataUri  String?
  ownerAddress String?
  isMinted     Boolean    @default(false)
  mintedAt     DateTime?
  rarityScore  Float?
  rarityRank   Int?
  percentile   Float?
  rarityTier   String?
  searchVector String?
  traitCount   Int        @default(0)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  traits       NftTrait[]
  // P2P Trading relation
  tradeItems   TradeItem[]

  @@unique([collectionId, tokenId])
  @@index([collectionId, rarityRank])
  @@index([collectionId, rarityScore])
  @@index([rarityTier])
  @@index([traitCount])
}

model NftTrait {
  id          String   @id @default(uuid())
  nftId       String
  traitType   String
  value       String
  displayType String?
  rarity      Float?
  frequency   Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  nft         Nft      @relation(fields: [nftId], references: [id], onDelete: Cascade)

  @@index([traitType, value])
  @@index([nftId])
  @@index([rarity])
}

model CollectionTrait {
  id           String                 @id @default(uuid())
  collectionId String
  traitType    String
  isRequired   Boolean                @default(false)
  totalValues  Int                    @default(0)
  totalNfts    Int                    @default(0)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  collection   Collection             @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  values       CollectionTraitValue[]

  @@unique([collectionId, traitType])
  @@index([collectionId])
}

model CollectionTraitValue {
  id        String          @id @default(uuid())
  traitId   String
  value     String
  frequency Int             @default(0)
  rarity    Float           @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  trait     CollectionTrait @relation(fields: [traitId], references: [id], onDelete: Cascade)

  @@unique([traitId, value])
  @@index([traitId, rarity])
}

model SearchIndex {
  id             String   @id @default(uuid())
  entityType     String
  entityId       String
  title          String
  description    String?
  keywords       String[]
  searchVector   String
  collectionId   String?
  creatorAddress String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([entityType, entityId])
  @@index([collectionId])
  @@index([creatorAddress])
}

model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  category  String
  value     String
  frequency Int      @default(1)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, value])
  @@index([userId, category])
}

model UserSuggestion {
  id         String   @id @default(uuid())
  userId     String
  category   String
  suggestion String
  confidence Float    @default(0.5)
  source     String
  metadata   Json?
  isAccepted Boolean?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, category])
  @@index([category, confidence])
}

model GlobalSuggestion {
  id        String   @id @default(uuid())
  category  String
  value     String
  usage     Int      @default(1)
  trending  Boolean  @default(false)
  userType  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([category, value])
  @@index([category, trending])
  @@index([category, usage])
}

model UserFollow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("UserFollows", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model UserSocial {
  id       String @id @default(uuid())
  platform String
  url      String
  userId   String
  user     User   @relation("UserSocials", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform])
}

model UserList {
  id          String     @id @default(uuid())
  userId      String
  name        String
  description String?
  type        String     @default("custom") // watchlist, favorites, custom
  isPublic    Boolean    @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       ListItem[]

  @@index([userId, type])
  @@index([type])
}

model ListItem {
  id           String   @id @default(uuid())
  listId       String
  itemType     String   // collection, nft, launchpad, user, game
  itemId       String   // The ID of the collection, NFT, project, user, or game
  collectionId String?  // For NFTs and collections
  metadata     Json?    // Store additional data like name, image, etc.
  addedAt      DateTime @default(now())
  list         UserList @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@unique([listId, itemType, itemId])
  @@index([listId, addedAt])
  @@index([itemType, itemId])
}

// P2P Trading Models

model Trade {
  id                String        @id @default(uuid())
  initiatorId       String
  counterpartyId    String
  status            TradeStatus   @default(DRAFT)
  escrowAddress     String?       // Contract address once deployed
  metadata          Json?         // Additional trade metadata
  fairnessScore     Float?        // Calculated fairness score
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  agreedAt          DateTime?     // When both parties agreed
  escrowDeployedAt  DateTime?     // When escrow contract was deployed
  finalizedAt       DateTime?     // When trade was completed
  canceledAt        DateTime?     // When trade was canceled
  
  // Relations
  initiator         User          @relation("TradeInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  counterparty      User          @relation("TradeCounterparty", fields: [counterpartyId], references: [id], onDelete: Cascade)
  items             TradeItem[]
  messages          TradeMessage[]
  history           TradeHistory[]

  @@index([initiatorId, status])
  @@index([counterpartyId, status])
  @@index([status])
  @@index([createdAt])
}

model TradeItem {
  id          String      @id @default(uuid())
  tradeId     String
  nftId       String?
  side        TradeSide   // INITIATOR or COUNTERPARTY
  tokenAmount Float?      // For ERC20 tokens
  tokenAddress String?    // Token contract address
  metadata    Json?       // Additional item metadata
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  // Relations
  trade       Trade       @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  nft         Nft?        @relation(fields: [nftId], references: [id], onDelete: SetNull)

  @@index([tradeId, side])
  @@index([nftId])
}

model TradeMessage {
  id        String   @id @default(uuid())
  tradeId   String
  userId    String
  message   String
  messageType MessageType @default(TEXT)
  metadata  Json?    // Additional message data
  createdAt DateTime @default(now())
  
  // Relations
  trade     Trade    @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tradeId, createdAt])
  @@index([userId])
}

model TradeHistory {
  id          String        @id @default(uuid())
  tradeId     String
  userId      String
  action      TradeAction
  oldStatus   TradeStatus?
  newStatus   TradeStatus?
  metadata    Json?         // Additional action data
  createdAt   DateTime      @default(now())
  
  // Relations
  trade       Trade         @relation(fields: [tradeId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tradeId, createdAt])
  @@index([userId])
}

// Enums
enum TradeStatus {
  DRAFT
  PENDING
  COUNTERED
  AGREED
  ESCROW_DEPLOYED
  DEPOSITED
  FINALIZED
  CANCELED
  REJECTED
}

enum TradeSide {
  INITIATOR
  COUNTERPARTY
}

enum MessageType {
  TEXT
  SYSTEM
  COUNTEROFFER
  ACCEPTANCE
  REJECTION
}

enum TradeAction {
  CREATED
  UPDATED
  COUNTEROFFER
  ACCEPTED
  REJECTED
  AGREED
  ESCROW_DEPLOYED
  DEPOSITED
  FINALIZED
  CANCELED
}
