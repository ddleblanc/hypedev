generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String              @id @default(uuid())
  walletAddress      String              @unique
  createdAt          DateTime            @default(now())
  bannerImage        String?
  bio                String?
  creatorAppliedAt   DateTime?
  creatorApprovedAt  DateTime?
  isCreator          Boolean             @default(false)
  profileCompleted   Boolean             @default(false)
  profilePicture     String?
  updatedAt          DateTime            @updatedAt
  username           String?             @unique
  creatorApplication CreatorApplication?
  projects           Project[]
  following          UserFollow[]        @relation("UserFollowing")
  followers          UserFollow[]        @relation("UserFollows")
  preferences        UserPreference[]
  socials            UserSocial[]        @relation("UserSocials")
  suggestions        UserSuggestion[]
  lists              UserList[]
}

model CreatorApplication {
  id                     String    @id @default(uuid())
  userId                 String    @unique
  creatorType            String
  displayName            String
  tagline                String?
  avatar                 String?
  banner                 String?
  bio                    String
  skills                 String[]
  portfolio              String?
  achievements           String?
  socialLinks            Json?
  contentTypes           String[]
  uploadFrequency        String
  targetAudience         String
  uniqueValue            String?
  acceptTerms            Boolean   @default(false)
  acceptCreatorAgreement Boolean   @default(false)
  understandFees         Boolean   @default(false)
  status                 String    @default("pending")
  submittedAt            DateTime  @default(now())
  reviewedAt             DateTime?
  reviewNotes            String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Project {
  id          String       @id @default(uuid())
  name        String
  description String
  banner      String?
  genre       String?
  concept     String?
  status      String       @default("draft")
  creatorId   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  collections Collection[]
  creator     User         @relation(fields: [creatorId], references: [id], onDelete: Cascade)
}

model Collection {
  id                String            @id @default(uuid())
  address           String            @unique
  name              String
  symbol            String
  description       String?
  image             String?
  bannerImage       String?
  profileImage      String?
  creatorAddress    String
  royaltyPercentage Float             @default(0)
  chainId           Int               @default(11155111)
  claimPhases       String?
  projectId         String?
  about             Json?
  story             String?
  utility           String?
  roadmap           Json?
  socialLinks       Json?
  teamMembers       Json?
  tags              String[]
  category          String?
  isDeployed        Boolean           @default(false)
  deployedAt        DateTime?
  transactionHash   String?
  totalSupply       Int               @default(0)
  maxSupply         Int?
  isVerified        Boolean           @default(false)
  isFeatured        Boolean           @default(false)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  contractType      String            @default("DropERC721")
  project           Project?          @relation(fields: [projectId], references: [id])
  collectionTraits  CollectionTrait[]
  nfts              Nft[]
}

model Nft {
  id           String     @id @default(uuid())
  tokenId      String
  collectionId String
  name         String
  description  String?
  image        String
  attributes   Json?
  metadataUri  String?
  ownerAddress String?
  isMinted     Boolean    @default(false)
  mintedAt     DateTime?
  rarityScore  Float?
  rarityRank   Int?
  percentile   Float?
  rarityTier   String?
  searchVector String?
  traitCount   Int        @default(0)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  traits       NftTrait[]

  @@unique([collectionId, tokenId])
  @@index([collectionId, rarityRank])
  @@index([collectionId, rarityScore])
  @@index([rarityTier])
  @@index([traitCount])
}

model NftTrait {
  id          String   @id @default(uuid())
  nftId       String
  traitType   String
  value       String
  displayType String?
  rarity      Float?
  frequency   Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  nft         Nft      @relation(fields: [nftId], references: [id], onDelete: Cascade)

  @@index([traitType, value])
  @@index([nftId])
  @@index([rarity])
}

model CollectionTrait {
  id           String                 @id @default(uuid())
  collectionId String
  traitType    String
  isRequired   Boolean                @default(false)
  totalValues  Int                    @default(0)
  totalNfts    Int                    @default(0)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  collection   Collection             @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  values       CollectionTraitValue[]

  @@unique([collectionId, traitType])
  @@index([collectionId])
}

model CollectionTraitValue {
  id        String          @id @default(uuid())
  traitId   String
  value     String
  frequency Int             @default(0)
  rarity    Float           @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  trait     CollectionTrait @relation(fields: [traitId], references: [id], onDelete: Cascade)

  @@unique([traitId, value])
  @@index([traitId, rarity])
}

model SearchIndex {
  id             String   @id @default(uuid())
  entityType     String
  entityId       String
  title          String
  description    String?
  keywords       String[]
  searchVector   String
  collectionId   String?
  creatorAddress String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([entityType, entityId])
  @@index([collectionId])
  @@index([creatorAddress])
}

model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  category  String
  value     String
  frequency Int      @default(1)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, value])
  @@index([userId, category])
}

model UserSuggestion {
  id         String   @id @default(uuid())
  userId     String
  category   String
  suggestion String
  confidence Float    @default(0.5)
  source     String
  metadata   Json?
  isAccepted Boolean?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, category])
  @@index([category, confidence])
}

model GlobalSuggestion {
  id        String   @id @default(uuid())
  category  String
  value     String
  usage     Int      @default(1)
  trending  Boolean  @default(false)
  userType  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([category, value])
  @@index([category, trending])
  @@index([category, usage])
}

model UserFollow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("UserFollows", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model UserSocial {
  id       String @id @default(uuid())
  platform String
  url      String
  userId   String
  user     User   @relation("UserSocials", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform])
}

model UserList {
  id          String     @id @default(uuid())
  userId      String
  name        String
  description String?
  type        String     @default("custom") // watchlist, favorites, custom
  isPublic    Boolean    @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       ListItem[]

  @@index([userId, type])
  @@index([type])
}

model ListItem {
  id           String   @id @default(uuid())
  listId       String
  itemType     String   // collection, nft, launchpad, user, game
  itemId       String   // The ID of the collection, NFT, project, user, or game
  collectionId String?  // For NFTs and collections
  metadata     Json?    // Store additional data like name, image, etc.
  addedAt      DateTime @default(now())
  list         UserList @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@unique([listId, itemType, itemId])
  @@index([listId, addedAt])
  @@index([itemType, itemId])
}
